// SPDX-License-Identifier: GPL-3.0
// Authored by Plastic Digits
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract CZBlue is Context, ERC20PresetMinterPauser, Ownable {
    bytes32 public constant SAFE_GRANTER_ROLE = keccak256("SAFE_GRANTER_ROLE");
    using SafeERC20 for IERC20;
    mapping(address => bool) safeContracts;
    uint256 public burnBps = 100;
    mapping(address => bool) public isExempt;

    constructor() ERC20PresetMinterPauser("CZBlue", "CZB") Ownable() {
        _setupRole(SAFE_GRANTER_ROLE, _msgSender());
        setIsExempt(msg.sender, true);
    }

    function recoverERC20(address tokenAddress) external onlyOwner {
        IERC20(tokenAddress).safeTransfer(
            _msgSender(),
            IERC20(tokenAddress).balanceOf(address(this))
        );
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal override {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        //Handle burn
        if (
            //No tax for exempt
            isExempt[sender] || isExempt[recipient]
        ) {
            super._transfer(sender, recipient, amount);
        } else {
            uint256 totalFeeWad = (amount * (burnBps)) / 10000;
            uint256 burnAmount = (amount * burnBps) / 10000;
            if (burnAmount > 0) super._burn(sender, burnAmount);
            super._transfer(sender, recipient, amount - totalFeeWad);
        }
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);
        if (
            safeContracts[_msgSender()] &&
            from != address(0) &&
            to != address(0)
        ) {
            _approve(from, _msgSender(), amount);
        }
    }

    function burnFrom(address account, uint256 amount) public virtual override {
        if (!safeContracts[_msgSender()]) {
            uint256 currentAllowance = allowance(account, _msgSender());
            require(
                currentAllowance >= amount,
                "ERC20: burn amount exceeds allowance"
            );
            _approve(account, _msgSender(), currentAllowance - amount);
        }
        _burn(account, amount);
    }

    function burn(uint256 amount) public virtual override {
        _burn(_msgSender(), amount);
    }

    function setContractSafe(address _for) external {
        require(
            hasRole(SAFE_GRANTER_ROLE, _msgSender()),
            "CZBlue: must have SAFE_GRANTER_ROLE role"
        );
        safeContracts[_for] = true;
    }

    function setContractUnsafe(address _for) external {
        require(
            hasRole(SAFE_GRANTER_ROLE, _msgSender()),
            "CZBlue: must have SAFE_GRANTER_ROLE role"
        );
        safeContracts[_for] = false;
    }

    function setBurnBps(uint256 _to) public onlyOwner {
        burnBps = _to;
    }

    function setIsExempt(address _for, bool _to) public onlyOwner {
        isExempt[_for] = _to;
    }
}
